def _get_docs(func):
    docs = func.doc
    docs = docs.split('\n')
    args = []
    kwargs = []
    rtype = None
    for doc in docs:
        if len(doc.split(':')) >= 3:
            match (docsplit:=doc.split(':')[1].split())[0]:
                case 'arg'|'param':
                    args.append(f"{docsplit[2]}: {docsplit[1]}" if len(docsplit)>2 else args.append(docksplit[1]))
                case 'var'|'kwarg':
                    index = doc.lower().index("default:") if "default:" in doc.lower() else None
                    default = doc[index+8:] if index is not None and len(doc)>=index else ""
                    kwargs.append((f"{docsplit[2]}: {docsplit[1]}" if len(docsplit)>2 else docksplit[1]) + (f" = {default}" if default else ""))
                case 'rtype':
                    rtype = doc.split(':')[2].strip()
    if len(args+kwargs)>4:
        n='\n'
        header = [f"""```py
{func.name}(
    {f',{n}    '.join(args+kwargs)}
){f' -> {rtype}' if rtype else ''}```"""]
    else:
        header = [f"""```py
{func.name}({', '.join(args+kwargs)}){f' -> {rtype}' if rtype else ''}```"""]
    docs = [f"`{x.lstrip(':').replace(':','`:')}" if x.startswith(":") else x for x in docs]
    return '\n'.join(header+docs)

def get_embed(functions: list=[get_embed], args: list|str = '', subcmd=''):
    """
    Create embed arguments for documentation.
    By default will show its own documentation
    :var functions: a list of functions
    :var args: 
    """
    newline = "\n"
    cmd = ctx.prefix + ctx.alias
    func_names = [x.name for x in functions]
    if typeof(args) == 'SafeList':
        args = ' '.join(args)
    elif typeof(args) == 'str':
        args = args.replace('"','').replace("'","")
    
    previous_funcs = load_yaml(get('docs_multiple_choice','[]'))
    if any([func_name not in func_names for func_name in previous_funcs]):
        previous_funcs = []
        delete_uvar('docs_multiple_choice')
        
    if previous_funcs:
        possible_func = [func for func in functions if any([func_name == func.name for func_name in previous_funcs])]
    else:
        possible_func = args and [func for func in functions if args in func.name]
    if args.isdecimal() and previous_funcs:
        index = max(int(args)-1,0)
        if len(previous_funcs)>index:
            func = functions[func_names.index(previous_funcs[index])]
            desc = _get_docs(func)
            delete_uvar('docs_multiple_choice')
            return f"-title ＂{ctx.author.display_name} decided on {func.name}＂ -desc ＂{desc}＂"
        else:
            desc = "That was not a valid option, try again\n" + '\n'.join([f"""{idx+1}. `{func.name}`: {func.doc.split(newline)[0]}""" for idx, func in enumerate(possible_func)])
            return f"-title ＂{ctx.author.display_name} couldn't make up their mind＂＂ -desc ＂{desc}＂"
    elif len(possible_func)>1:
        desc = f"**Multiple Matches Found**\nRerun `{cmd}{f' {subcmd}' if subcmd else ''} #` with the number that you want.\n" + '\n'.join([f"""{idx+1}. `{func.name}`: {func.doc.split(newline)[0]}""" for idx, func in enumerate(possible_func[:20])])
        set_uvar('docs_multiple_choice',dump_json([x.name for x in possible_func[:20]]))
        return f"-title ＂{ctx.author.display_name} couldn't make up their mind＂ -desc ＂{desc}＂"
    elif len(possible_func)==1:
        func = possible_func[0]
        desc = _get_docs(func)
        delete_uvar('docs_multiple_choice')
        return f"-title ＂{ctx.author.display_name} wants to know more about {func.name}＂ -desc ＂{desc}＂"
    else:
        desc = '\n'.join([f"""`{func.name}`: {func.doc.split(newline)[0]}""" for func in functions])
        delete_uvar('docs_multiple_choice')
        return f"-title ＂{ctx.author.display_name} wants to know what {ctx.alias}{f' {subcmd}' if subcmd else ''} has＂ -desc ＂{desc}＂"
