#Define constants
asterisk = '\\*'
openModes = ["none","one","all"]
doesntdont = ["doesn't","don't"]
ch = character()
a_bag = [str, dict]

#Load user variable
DEFAULT_COIN_RATES = {"pp":0.1,"gp":1,"ep":2,"sp":10,"cp":100}
DEFAULT_COIN_EMOJIS = {"cp":"<:DDBCopper:953399505129205830>","sp":"<:DDBSilver:953399505124995122>","ep":"<:DDBElectrum:953399505129205831>","gp":"<:DDBGold:953399505062080594>","pp":"<:DDBPlatinum:953399504739106847>"}
COIN_RATES = list((load_yaml((get_svar("coinRates") or ch.cvars.get("coinRates", "[]")).lower()) or DEFAULT_COIN_RATES).items())
COIN_RATES.sort(key=lambda x: x[1])
COIN_RATES = dict(COIN_RATES)
COIN_TYPES = list(COIN_RATES)
DEFAULT_COIN = [coin for coin, rate in COIN_RATES.items() if rate == 1]
DEFAULT_COIN = DEFAULT_COIN[0] if DEFAULT_COIN else COIN_TYPES[0]
coinPouchName = get_svar("coinPouchName") or ch.cvars.get("coinPouchName","Coin Pouch")
coinWeighs = float(get_svar("coinWeighs") or ch.cvars.get("coinWeighs",0.02))

for var in ['coinRates','coinPouchName','coinWeighs']:
    if (svar:=get_svar(var)):
        ch.set_cvar(var, svar)

default_packs = [["Priest's Pack",{"Backpack":1,"Blanket":1,"Candle":10,"Tinderbox":1,"Alms Box":1,"Block of Incense":2,"Censer":1,"Vestments":1,"Days of Rations":2,"Waterskin (Full)":1}],["Burglar's Pack",{"Backpack":1,"Ball Bearings (Bag of 1,000)":1,"String (10 feet)":1,"Bell":1,"Candle":5,"Crowbar":1,"Hammer":1,"Pitons":10,"Hooded Lantern":1,"Oil (Flask)":2,"Days of Rations":5,"Tinderbox":1,"Waterskin (Full)":1,"Hempen Rope (50 feet)":1}],["Scholar's Pack",{"Backpack":1,"Book of Lore":1,"Ink (1 ounce Bottle)":1,"Ink Pen":1,"Parchment (Sheet)":10,"Little Bag of Sand":1,"Small Knife":1}],["Diplomat's Pack",{"Chest":1,"Map or Scroll Case":2,"Fine Clothes":1,"Ink (1 ounce Bottle)":1,"Ink Pen":1,"Lamp":1,"Oil (Flask)":2,"Paper (Sheet)":5,"Perfume (Vial)":1,"Sealing Wax":1,"Soap":1}],["Explorer's Pack",{"Backpack":1,"Bedroll":1,"Mess Kit":1,"Tinderbox":1,"Torch":10,"Days of Rations":10,"Waterskin (Full)":1,"Hempen Rope (50 feet)":1}],["Dungeoneer's Pack",{"Backpack":1,"Crowbar":1,"Hammer":1,"Piton":10,"Torch":10,"Tinderbox":1,"Days of Rations":10,"Waterskin (Full)":1,"Hempen Rope (50 feet)":1}],["Entertainer's Pack",{"Backpack":1,"Bedroll":1,"Clothes, Costume":2,"Candle":5,"Days of Rations":5,"Waterskin (Full)":1,"Disguise Kit":1}],["Monster Hunter's Pack",{"Chest":1,"Crowbar":1,"Hammer":1,"Wooden Stake":3,"Holy Symbol":1,"Holy Water (Flask)":1,"Manacles":1,"Steel Mirror":1,"Oil (Flask)":1,"Tinderbox":1,"Torch":3}],["Soldier's Pack",{"Backpack":1,"Bedroll":1,"Fuse (50 feet)":1,"Small Knife":1,"Mess Kit":1,"Musket":1,"Musket Bullets":100,"Tinderbox":1,"Torch":10,"Shovel":1,"Waterskin":1,"Vial of Antitoxin":1,"Hempen Rope (50 feet)":1}],["Exploder's Pack",{"Gunpowder Horn":3,"Gunpowder Keg":1,"Tinderbox":1,"Torch":10,"Oil (Flask)":3,"Fuse (50 feet)":1}]]
hb_packs = load_yaml(get_svar("extraPacks",'[]'))+load_yaml(ch.cvars.get("extraPacks",'[]'))

packs = default_packs + hb_packs

pbRaces = ["bugbear","firbolg","goliath","orc"]
pbRaces = pbRaces+(hb_pbRaces:=load_yaml(ch.cvars.get("powerfulBuildRaces","[]"))+load_yaml(get_svar("powerfulBuildRaces","[]")))

default_settings = {"weightlessBags":["bag of holding","handy haversack","heward's handy haversack"],"customWeights":{},"weightTracking":"Off","openMode":"All","encumbrance":"Off","autoCoins":False}
settings = load_yaml(ch.cvars.get("bagSettings",dump_json(default_settings)))
if not "openMode" in settings or not settings.openMode.lower() in openModes:
    settings.update({"openMode":"All"})
if not "encumbrance" in settings:
    settings.update({"encumbrance":"Off"})
if not "autoCoins" in settings:
    settings.update({"autoCoins":False})
    
weightDict = load_yaml(get_gvar("19753bce-e2c1-42af-8c4f-baf56e2f6749"))
custWeights = settings.get('customWeights', {})
custWeights.update(server_weights := load_yaml(get_svar("bag_custom_weights","{}")))
weightDict.update(custWeights)

carryMod = ch.stats.strength*(2 if ch.cvars.get('race',ch.race).lower() in pbRaces else 1)*(2 if load_yaml(ch.cvars.get('subclass','{}')).get("BarbarianLevel","") == "Totem Warrior" and ch.cvars.get("l6totem","") == "Bear" else 1)

#Define functions
def load_bags(ch = character()) -> [a_bag]:
    """
    Loads the current character's bags as a list.
    :arg ch: The current character, will be loaded if none is provided.
    :return: a list of bags
    """
    
    # grab the list of cvars
    cvars = ch.cvars
    
    # update legacy bags to new format
    old_bags = [load_yaml(cvars[x]) for x in cvars if "bag" in x and x.strip("bag").isdecimal()]
    old_bags_converted = [[bag[0],{bag[item_index].i:bag[item_index].q for item_index in range(1,len(bag))}] for bag in old_bags]
    for i in range(len(old_bags)):
        ch.delete_cvar(f"bag{i}")
    
    # load bags
    bagsLoaded = load_yaml(ch.cvars.get('bags', '[]'))
    bagsLoaded = bagsLoaded + old_bags_converted
    
    # remove duplicate names
    bag_names = [bag[0] for bag in bagsLoaded]
    if any([bag_names.count(bag_name)>1 for bag_name in bag_names]):
        for bag in bagsLoaded:
            if bag_names.count(bag[0]) > 1:
                i = int(bag[0].split(' ')[-1]) if bag[0].split(' ')[-1].isdecimal() else 1
                while [bag[0] for bag in bagsLoaded].count(bag[0]) > 1:
                    i += 1
                    bag[0] = f"""{bag[0].rstrip(" 1234567890")} {i}"""
    return bagsLoaded

def save_bags(bagsLoaded: list, error = False, ch = character()) -> int:
    """
    Saves the current bag configuration.
    :var bagsLoaded: The dict or list of bags
    :arg error: Whether an error occurred before trying to save
    :arg ch: The current character, will be loaded if none is provided.
    :return: the success state; 0 for no bags, 1 for success, and -1 for failure
    """
    # check if there was an error, or if the provided bags are in the wrong format
    if error or typeof(bagsLoaded) not in ['SafeDict','SafeList']:
        return -1
    
    # if there are no more bags, remove the bags cvar
    elif not bagsLoaded:
        ch.delete_cvar('bags')
        return 0
    
    # dumb the bags in the appropriate way
    elif typeof(bagsLoaded) == 'SafeDict':
        ch.set_cvar('bags',dump_json(list(bagsLoaded.items())))
    else:
        ch.set_cvar('bags',dump_json(bagsLoaded))
    return 1

def get_bag(bagsLoaded: list, bag_id, exact_match=False, create_on_fail=False) -> a_bag:
    """
    Retrieves a bag from the provided list, given the name or index.
    :arg bagsLoaded: the list of bags to search
    :arg bag_id: the identifier, either index or name, to try to find
    :var exact_match: whether to only return the bag if it's an exact match
    :var create_on_fail: whether to create a new bag if one is not found
    :return: a bag
    """
    bagsLoaded = _as_list(bagsLoaded) # ensure bags are in list format
    
    # try to grab the bag from the list position
    if typeof(bag_id) == 'int':
        position = max(min(len(bagsLoaded)-1, bag_id), 0)
        bag = bagsLoaded[position]
        return bag
    
    # try to grab the bag by name, getting progressivly fuzzier if an exact match is not needed
    bag = [b for b in bagsLoaded if b[0] == bag_id]
    if not bag and not exact_match:
        bag = [b for b in bagsLoaded if bag_id.lower() == b[0].lower()]
    if not bag and not exact_match:
        bag = [b for b in bagsLoaded if bag_id in b[0]]
    if not bag and not exact_match:
        bag = [b for b in bagsLoaded if bag_id.lower() in b[0].lower()]
    
    # create a new bag if the argument is enabled
    if not bag and create_on_fail:
        return new_bag(bagsLoaded, bag_id)
    # return the bag
    if not bag:
        return None
    else:
        bag = bag[0]
        return [bag[0], bag[1]]
    
def new_bag(bagsLoaded: list, bag_name = "New Bag") -> a_bag:
    """
    Creates a new bag with the given name.
    Will try to find an unused name if the given one is not available
    :arg bagsLoaded: the list of bags to create in
    :var bag_name: the name of the new bag
    :return: a bag
    """
    bag_name = bag_name or "New Bag"
    bagsLoaded = _as_list(bagsLoaded)
    bag_name = find_valid_name(bagsLoaded, bag_name) # check for a name that is unused
    bagsLoaded.append([bag_name, {coin:0 for coin in COIN_TYPES} if bag_name == coinPouchName else {}])
    return bagsLoaded[-1]
    
def modify_item(bagsLoaded: list, item, quantity=1, bag_name=None, create_on_fail=False, recursive_search = False) -> (a_bag, bool):
    """
    Modifies an item in a bag by a given quantity.
    :arg bagsLoaded: the list of bags to modify
    :arg item: the name of the item to modify
    :var quantity: the delta of the item to modify, positive adds, negative removes
    :var bag_name: the desired bag to search in, otherwise uses the first bag with the item already in it
    :var create_on_fail: whether to create a new bag if one is not found
    :var recursive_search: whether to search for other bags that contain the requested item, only if quantity is negative
    :return: a tuple containing the modified bag and a bool which represents whether there was an error
    """
    # setup variables
    bagsLoaded = _as_list(bagsLoaded)
    bag = None
    error = True
    quantity = int(quantity)
    
    # try to find a bag with the given name, failing to do so, fallback to searching for a bag with the item already in it
    if bag_name:
        bag = get_bag(bagsLoaded, bag_name)
    if not bag:
        bag = find_bag_with_item(bagsLoaded, item)
        recursive_search = True
        
    # create a new bag if the option is set, otherwise grab the first bag in the list
    if not bag and create_on_fail:
        bag = new_bag(bagsLoaded, bag_name)
    if not bag and len(bagsLoaded)>0:
        bag = get_bag(bagsLoaded, 0)
    if not bag:
        return (bag_name, error)
    
    # try to find the closest match for the item we want, ignoring case
    item_names = [x for x in bag[1] if item.lower() == x.lower()]
    item_name = item_names[0] if item_names else item
    
    # save the current quantity of the item, then make sure that we have enough of the item in the bag
    c_value = bag[1][item_name] if item_names else 0
    if (c_value >= -quantity or recursive_search):
        
        # update the bag's values, remove the entry if it's empty
        bag[1][item_name] = remainder = (c_value + quantity)
        if bag[1][item_name] <= 0:
            bag[1].pop(item_name)
        if remainder < 0 and recursive_search:
            return _remove_item_recursive(bagsLoaded, item, remainder, bag[0])
        error = False
    return (bag, error)

def _remove_item_recursive(bagsLoaded: list, item: str, remainder: int, first_bag: str = None) -> a_bag:
    """
    Handles fuzzy item removal from multiple bags if there is not enough in a single bag
    :arg bagsLoaded: the list of bags
    :arg item: the name of the item you're trying to remove
    :arg remainder: how many more of the item you need to remove
    :return: a bag representing the bags accessed
    """
    # define variables
    bagsLoaded = _as_list(bagsLoaded)
    total_items = 0
    names = [first_bag] if first_bag else []
    
    # loop though each bag, removing as many of the item as possible until remainder consumed
    for bag in bagsLoaded:
        item_names = [x for x in bag[1] if item.lower() == x.lower()]
        item_name = item_names[0] if item_names else item
        c_value = bag[1][item_name] if item_names else 0
        total_items += c_value
        if c_value > 0 and remainder < 0:
            names.append(bag[0])
            bag[1][item_name] = (remainder := remainder + c_value)
            # remove entry if empty
            if remainder < 1:
                bag[1].pop(item_name) if item_names else ()
    
    # show in one bag mode that multiple bags were used
    if len(names)>1:
        names[-1] = "and " + names[-1]
    if remainder < 0:
        return ([", ".join(names), {item: total_items}], True)
    else:
        return ([", ".join(names), {item: total_items}], False)

def modify_coins(bagsLoaded: list, coin: str=None, quantity: float|int=0, coins: dict = {}, autoCoins: bool = None, ch=character()) -> (a_bag, bool):
    """
    Modifies the coin pouch or coin purse automatically.
    Handles automatic switching depending if non-standard coins are in use.
    Returns the coin bag or a bag representing the coin purse, as well as a bool for error handling
    :arg bagsLoaded: list of all the bags
    :arg coin: the coin that is being modified
    :var quantity: how much to change the coins by
    :var coins: instead of coin or quantity you can provide coins, a dict of coins and quantities
    :var ch: the character, can be passed through if already loaded
    :return: a bag representing the coins access, and an error bool
    """
    # define variables
    bagsLoaded = _as_list(bagsLoaded)
    pouch = get_coins(bagsLoaded, ch)
    autoCoins = settings.get('autoCoins',False) if autoCoins is None else autoCoins
    
    # check if coins are valid
    error = any([coin.lower() not in COIN_TYPES for coin in coins]) or (coin and coin.lower() not in COIN_TYPES)
    total = 0
    coin = (coin or DEFAULT_COIN).lower()
    coins = coins.copy()
    
    #prepare the coin diff
    if not error:
        for coin_type in COIN_TYPES:
            if coin_type not in coins:
                coins[coin_type]=0
        coins.update({coin:coins[coin]+quantity} if quantity else {})
        
        # smooth out any floating point entries
        for coin in COIN_TYPES[:-1:-1]:
            if (decimal:=coins.get(coin,0) % 1):
                index = COIN_TYPES.index(coin)
                smaller = COIN_TYPES[index+1]
                rate = COIN_RATES[smaller]/COIN_RATES[coin]
                p = decimal*rate
                if index == len(COIN_TYPES)-2 and p%1:
                    return (pouch, True)
                coins.update({smaller:coins.get(smaller,0)+p,coin:int(coins.get(coin,0)-decimal)})
        
        # finally ensure all are int and calculate total
        for coin in coins:
            coins[coin] = int(coins[coin])
            total += coins[coin]/COIN_RATES[coin]
    else:
        coins = None
    
    #prepare coins regardless of if it's coin pouch or coin purse
    if not error:
        for coin in coins:
            pouch[1][coin] += coins[coin]
        
        # after modifying the coins, do autoconversions, and check if you actually have enough
        for coin in COIN_TYPES[1::-1]:
            if pouch[1][coin] < 0:
                larger = COIN_TYPES[COIN_TYPES.index(coin)-1]
                rate = COIN_RATES[coin]/COIN_RATES[larger]
                p = pouch[1][coin]//rate
                pouch[1].update({larger:pouch[1][larger]+p, coin:pouch[1][coin]-p*rate})
        
        # convert into higher denominations if the settings is enabled
        if autoCoins:
            for coin in COIN_TYPES[:-1:-1]:
                smaller = COIN_TYPES[COIN_TYPES.index(coin)+1]
                rate = COIN_RATES[smaller]/COIN_RATES[coin]
                p = pouch[1][smaller]//rate
                if pouch[1][smaller] >= rate:
                    pouch[1].update({smaller:pouch[1][smaller]-p*rate,coin:pouch[1][coin]+p})
                
        error = any([pouch[1][coin]<0 for coin in pouch[1]]) or error
        
        # if the modifications were successful, dump to actual coin purse
        if not error and use_coin_purse(bagsLoaded):
            ch.coinpurse.set_coins(pouch[1].pp,pouch[1].gp,pouch[1].ep,pouch[1].sp,pouch[1].cp)
    return (pouch, error)

def get_coins(bagsLoaded: list, ch=character()) -> a_bag:
    """
    Returns a bag of how many coins you currently have.
    Will not update your coins if modified.
    :arg bagsLoaded: a list of bags
    :return: a bag representing your coins
    """
    # check if we are using coin purse or not
    if use_coin_purse(bagsLoaded):
        cname = "Coin Purse"
        purse = ch.coinpurse
        coins = {coin:purse[coin] for coin in COIN_TYPES}
        pouch = [cname, coins]
    else:
        pouch = get_bag(bagsLoaded, coinPouchName, exact_match=True, create_on_fail=True)
        for coin_type in COIN_TYPES:
            if coin_type not in pouch[1]:
                pouch[1][coin_type] = 0
    return pouch

def use_coin_purse(bagsLoaded: list) -> bool:
    """
    Checks if coin purse should be used.
    Returns a boolean
    :arg bagsLoaded: The list of bags to check
    :return: a bool of whether to use the coin purse
    """
    bagsLoaded = _as_list(bagsLoaded)
    return not get_bag(bagsLoaded, coinPouchName, exact_match = True) and COIN_RATES == DEFAULT_COIN_RATES

def parsecoins(args: str|list):
    """
    Parses args to get the valid coins.
    (I hate that I can't shadow here)
    :arg args: the string or list of arguments to parse
    :return: tuple of a dict of coin totals and an error bool
    """
    if typeof(args) == 'SafeList':
        args = ' '.join(args)
    args = [arg.strip() for arg in args.split("+") if arg]
    new_args = []
    for arg in args:
        new_args += [f"{'-' if idx else ''}{part}" for idx, part in enumerate(arg.split("-")) if part]
    args = new_args
    #for arg in new_args:
    #    new_args += [part for part in arg.split()]
    coins = {}
    for arg in args:
        error = False
        if arg.replace("-","").strip().isdecimal():
            coin = DEFAULT_COIN
            arg = arg.strip()
        elif len(possible_types:=[coin for coin in COIN_TYPES if coin.lower() in arg.lower()]) == 1:
            coin = possible_types[0]
            arg = arg.lower().replace(coin.lower(),"").strip()
        else:
            return {}, True
        if all([number.strip().isdecimal() for number in (numbers:=arg.strip("-").replace(",","").split("."))]) and len(numbers) in [1,2]:
            quantity = float(arg.replace(",",""))
            if quantity:
                coins.update({coin:coins.get(coin,0)+quantity})
        else:
            return {}, True
    
    return coins, False
        
def find_bag_with_item(bagsLoaded: list, item: str) -> a_bag:
    """
    Finds and returns the first bag with a given item in it.
    :arg bagsLoaded: the list of bags to search in
    :arg item: the desired item
    :return: a bag
    """
    bagsLoaded = _as_list(bagsLoaded)
    for bag_name, items in bagsLoaded:
        if any([item.lower() in i.lower() for i in items]):
            return [bag_name, items]
    return None

def find_valid_name(a_dict: dict, input_str: str) -> str:
    """
    Finds a unique permutation for a key given a dict and a name.
    :arg a_dict: the dict to search in
    :arg input_str: the base name to check with
    :return: a similar string which is not used as a key
    """
    a_dict = _as_dict(a_dict)
    i = int(input_str.split(' ')[-1]) if input_str.split(' ')[-1].isdecimal() else 1
    while input_str in a_dict:
        i += 1
        input_str = f"""{input_str.rstrip(" 1234567890")} {i}"""
    return input_str

def rename_bag(bags_dict: dict, old_name: str, new_name: str) -> (str, str):
    """
    Renames a bag given the old name, and a new name.
    :arg bags_dict: the dict of bags to modify
    :arg old_name: the current name of the bag
    :arg new_name: the new name of the bag
    :return: a tuple of the old name and the new name as strings
    """
    bags_dict = _as_dict(bags_dict)
    old_bag = get_bag(bags_dict, old_name)
    if not old_bag:
        return (old_name, None)
    new_name = find_valid_name(bags_dict, new_name)
    bags_dict[new_name] = bags_dict.pop(old_bag[0])
    return (old_bag[0], new_name)

def swap_pos(bagsLoaded: list, bag_name: str, position=1) -> (str, int):
    """
    Swaps the position of a bag in the display.
    :arg bagsLoaded: the list of bags to modify
    :arg bag_name: the name of the bag you want to move
    :var position: the new position you want the bag in, indexed from 1
    :return: a tuple of the name and the new position, or `(None, -1)` if the bag didn't exist
    """
    bag = get_bag(bagsLoaded, bag_name)
    if not bag:
        return None, -1
    bagsLoaded.remove([bag[0], bag[1]])
    position = max(min(len(bagsLoaded), position), 1)
    bagsLoaded.insert(position-1, bag)
    return bag[0], position

def delete_bag(bagsLoaded: list, bag_name: str) -> (str, bool):
    """
    Deletes the bag with the given name.
    :arg bagsLoaded: the list to remove the bag from
    :arg bag_name: the name of the bag to remove, exact match required
    :return: the name of the bag attemped to be deleted, and a bool of whether it was successful
    """
    bagsLoaded = _as_list(bagsLoaded)
    old_bag = get_bag(bagsLoaded, bag_name, exact_match=True)
    if not old_bag:
        return (bag_name, True)
    bagsLoaded.remove(old_bag)
    return (old_bag[0], False)

def set_custom_weight(item_name: str, weight: float=None, cost: str=None, bundle: int=None) -> int:
    """
    Adds a custom weight to the custWeights cvar.
    :arg item_name: the name of the item you want to configure
    :var weight: the weight of the item represented as a float or int
    :var cost: the cost of the item, represented as <number><denomination> eg "1gp" for 1 gold piece
    :var bundle: how many items in a bundle, this is the grouping you have to buy these items in
    :return: a boolean representing the success of the modification
    """
    # build item config dict
    item = (custWeights.get(item_name) or custWeights.get(item_name.lower(), {})) | {x: y for x, y in [('weight', weight), ('cost', cost), ('bundle', bundle)] if y is not None}
    success = False
    if item:
        custWeights.update({item_name.lower(): item})
        success = True
    return success

def get_item_weight(item: str, fuzzyItemCount: int = 0, weightDict: dict = weightDict) -> (float|str, int, bool):
    """
    Grabs the weight of the given item.
    Also allows keeping track of how many items have used a fuzzy search, which is more intensive.
    :arg item: the name of the item
    :var fuzzyItemCount: the current count of how many fuzzy matches have been made
    :return: the weight as a float, the number of fuzzy items total as an int, and whether no matching weight was found as a bool.
    """
    item_name = item.lower()
    unknownItem = False
    if item_name in weightDict:
        itemWeight = (weightDict[item_name] if typeof(weightDict[item_name]) != "SafeDict" else weightDict[item_name].weight)
    elif item_name in COIN_TYPES:
        itemWeight = coinWeighs
    elif "pouch" in item_name:
        itemWeight = 1
    elif "potion" in item_name:
        itemWeight = 0.5
    elif fuzzyItemCount<5:
        fuzzyItemCount += 1
        itemWeight = ([(weightDict[y].get("weight") if typeof(weightDict[y]) == "SafeDict" else weightDict[y]) for y in weightDict if y in item_name]+["†"])[0]
    else:
        itemWeight = "†"
        unknownItem = True
        
    return itemWeight, fuzzyItemCount, unknownItem
    
def weigh_bag(
    bag: a_bag,
    weightDict: dict = weightDict,
    weightTracking: bool = (settings.get('weightTracking','Off').lower() == 'on'),
    ignoreBags: list = settings.get('weightlessBags',["bag of holding","handy haversack","heward's handy haversack"])
    ) -> (float, float, int):
    """
    Returns a tuple of values relevant to the weighing of a bag.
    :arg bag: the bag to get the weight of
    :return: the total and coin weight in lbs as floats, and the total number of fuzzy matches as an int
    """
    # define variables
    total_weight = 0
    coin_weight = 0
    fuzzyItemCount = 0
    
    # loop over all the items in the bag, getting the necessary information for each
    for item in bag[1]:
        if weightTracking and bag[0].lower() not in ignoreBags:
            unknownItem = False
            item_name = item.lower()
            itemWeight, fuzzyItemCount, _ = get_item_weight(item, fuzzyItemCount, weightDict)
            
            itemWeight = itemWeight*(bag[1][item] if typeof(itemWeight) != 'str' else 1)
            
            if typeof(itemWeight) != 'str':
                total_weight += itemWeight
                if item_name in COIN_TYPES:
                    coin_weight += itemWeight
    
    return float(total_weight), float(coin_weight), fuzzyItemCount

def display_bag(
    bag: a_bag,
    weightDict: dict = weightDict,
    weightTracking: bool = (settings.get('weightTracking','Off').lower() == 'on'),
    ignoreBags: list = settings.get('weightlessBags',["bag of holding","handy haversack","heward's handy haversack"]),
    old_bag: dict = None
    ) -> (list, float, float, int, bool):  #TODO: handle recursive bags
    """
    Creates the field(s) to display a bag in an embed.
    :arg bag: the bag to get the weight of
    :var weightDict: the dict to get weights from
    :var weightTracking: whether to use weight tracking
    :var ignoreBags: a list of what bags are ignored
    :var old_bag: the bag's contents previous state, for building a delta from
    :return: a list of fields to display a bag, the total weight of the bag, the weight of the coins, the total number of fuzzy matches, as well as a bool of whether any items had no matches
    """
    
    # define variables
    item_messages = []
    total_weight = 0
    coin_weight = 0
    fuzzyItemCount = 0
    anyUnknownItem = False
    
    # loop over each item, getting the information needed for the display
    for item in bag[1]:
        item_name = item.lower()
        quantity = bag[1][item]
        
        if item_name in COIN_TYPES and COIN_TYPES == list(DEFAULT_COIN_RATES):
            item_message = f"""{DEFAULT_COIN_EMOJIS[item_name]} {quantity:,} {item}""".strip()
        else:
            item_message = f"""{quantity:,}{"" if item_name in COIN_TYPES else "x"} {item}""".strip()
        
        # get item amount differences
        if old_bag is not None:
            diff = quantity - old_bag.get(item, 0)
            if diff:
                item_message += f''' ({"+" if diff>0 else ""}{diff})'''
        
        # start weight calculation
        if weightTracking and bag[0].lower() not in ignoreBags: # only weigh the bag if it's enabled
            itemWeight, fuzzyItemCount, unknownItem = get_item_weight(item, fuzzyItemCount)
            anyUnknownItem = anyUnknownItem or unknownItem
            
            itemWeight = itemWeight*(quantity if typeof(itemWeight) != 'str' else 1)
            
            if typeof(itemWeight) != 'str':
                total_weight += itemWeight
                if item_name in COIN_TYPES:
                    coin_weight += itemWeight
            
            # add the correct message based on the weight
            if typeof(itemWeight) in ['int','float']:
                item_message +=  f''' [{_round_nicely(itemWeight)} lbs.]{asterisk if unknownItem else ""}'''
            else:
                item_message += f" {itemWeight}" if itemWeight else ""
                
        item_messages.append(item_message)
    
    # show empty message
    if not item_messages:
        item_messages = ['*This bag is empty.*']
    
    # add weight counter for coins and total for each bag
    if coin_weight:
        item_messages.append(f"""**Coin Weight:** {_round_nicely(coin_weight)} lbs.""")
    bag_title = f"""{bag[0]}{"†" if anyUnknownItem else f''' ({_round_nicely(total_weight)} lbs.)''' if total_weight else ""}"""
    
    # split up fields if they are too long
    fields = []
    i = 0
    while item_messages:
        header = bag_title if i == 0 else "*(continued)*"
        lineLength = len(header)
        item_message = item_messages.pop(0)
        fields.append(f"-f ＂{header}|{item_message}")
        lineLength = max(lineLength, len(item_message))
        while len(fields[i]) <= 1000:
            if not item_messages:
                break
            item_message = item_messages.pop(0)
            fields[i] += f"\n{item_message}"
            lineLength = max(lineLength, len(item_message))
        fields[i] += "|inline＂" if lineLength <= 30 else "＂"
        i += 1
    
    return fields, float(total_weight), float(coin_weight), fuzzyItemCount, anyUnknownItem
    

def create_display(bagsLoaded: list = None, focus: a_bag = None, openMode: str = None, old_bags: dict = None) -> list:
    """
    Creates the full display for a list of bags.
    If a focus is provided but bagsLoaded is not, displays focus instead.
    :var bagsLoaded: the list of bags to display for the 'All' mode
    :var focus: a bag to focus on for the 'One' mode
    :var openMode: an override to the open mode
    :var old_bags: a copy of bagsLoaded made before any changes were made, used for item diffs. Make sure the copy is deep by running baglib.deep_copy(bagsLoaded)
    :return: a list of embed arguments to display the list of bags
    """
    # define variables
    openMode = openMode.lower() if openMode and openMode.lower() in openModes else settings.get('openMode','All').lower()
    text = []
    weightTracking = settings.get('weightTracking','Off').lower() == 'on'
    ignoreBags = settings.get('weightlessBags',["bag of holding","handy haversack","heward's handy haversack"])
    old_bags = None if old_bags is None else _as_dict(old_bags)
    
    # reload settings, just in case
    custWeights = settings.get('customWeights', default_settings.customWeights)
    custWeights.update(load_yaml(get_svar("bag_custom_weights","{}")))
    weightDict.update(custWeights)
    
    # define loop based on what mode we're in
    match openMode:
        case 'none':
            loop = []
        case 'all' if bagsLoaded:
            bagsLoaded = _as_list(bagsLoaded)
            coinbag = [get_coins(bagsLoaded)]
            loop = bagsLoaded + (coinbag if use_coin_purse(bagsLoaded) else [])
        case _:
            loop = [focus] if focus else []
            
    if not loop:
        return "-desc ＂There are no bags to display.＂"
    else:
        carriedWeight = 0
        unknownTotal = 0
        anyUnknownItem = False
        
        # loop over the bags
        for bag in loop:
            if not bag:
                continue
            old_bag = None if old_bags is None else old_bags.get(bag[0], {})
            fields, bag_weight, _, fuzzyItemCount, UnknownItems = display_bag(bag, weightDict, weightTracking, ignoreBags, old_bag)
            text += fields
            anyUnknownItem = anyUnknownItem or UnknownItems
            carriedWeight += bag_weight
            unknownTotal += fuzzyItemCount
        # add footnotes based on weight results
        if weightTracking and openMode == 'all':
            display_footer = f'''-f ＂Total Weight Carried: {_round_nicely(carriedWeight)}{asterisk*(unknownTotal>0)} lbs.|Carrying Capacity: {carryMod*15} lbs.'''
            if anyUnknownItem:
                display_footer += "\n*Items marked with a dagger (†) are entirely unrecognized.*"
            if unknownTotal:
                display_footer += f"""\n{asterisk+f"You have {unknownTotal} item{'s'*(unknownTotal>1)} which {doesntdont[unknownTotal>1]} have an exact match in the database."}"""
            display_footer += "＂"
            
            text.append(display_footer)
        
        # show encumbrance footer even if 'all' mode is not selected
        if weightTracking and settings.get('encumbrance','Off').lower() == 'on':
            if openMode not in 'all':
                carriedWeight = carried_weight(bagsLoaded)
            encumbrance_footer = """\n -f ＂You are Heavily Encumbered| Your speed is reduced by 20 feet and you have disadvantage on ability checks, attack rolls, and saving throws that use Strength, Dexterity, or Constitution.＂""" if carriedWeight>(carryMod*10) else """ -f ＂You are Encumbered|Your speed is reduced by 10 feet.＂""" if carriedWeight>(carryMod*5) else ""
            text.append(encumbrance_footer)
    return text

def carried_weight(bagsLoaded: list) -> float:
    """
    Calculates the total weight of a list of bags.
    :arg bagsLoaded: the list of bags
    :return: a float representing the total weight
    """
    bagsLoaded = _as_list(bagsLoaded)
    coinbag = [get_coins(bagsLoaded)]
    loop = bagsLoaded + coinbag if coinbag not in bagsLoaded else []
    carriedWeight = 0
    
    # reload settings, just in case
    custWeights = (settings.get('customWeights', default_settings.customWeights))
    custWeights.update(load_yaml(get_svar("bag_custom_weights","{}")))
    weightDict.update(custWeights)
    
    for bag in loop:
            bag_weight, _, _ = weigh_bag(bag, weightDict, 'on')
            carriedWeight += bag_weight
    return float(carriedWeight)

def deep_copy(a_list: list) -> list:
    """
    Provides a deep copy of a list.
    Idk just thought this'd be useful with baglib.
    :arg a_list: any list
    :return: a deep copy of the list
    """
    return load_json(dump_json(a_list))

def _as_dict(listordict) -> dict:
    """
    Makes sure a list is returned as a dict
    :var listordict: The list or dict to check
    :return: a dict
    """
    match typeof(listordict):
        case 'SafeDict':
            return listordict
        case 'SafeList' if len(listordict) == 0 or len(max(listordict, key=len)) == 2:
            return dict(listordict)
        case _:
            err(f"{typeof(listordict)} cannot be converted to a dict.\n{listordict} caused this error.",True)
            
def _as_list(listordict) -> list:
    """
    Makes sure a dict is returned as a list of lists
    :var listordict: The list or dict to check
    :return: a list
    """
    match typeof(listordict):
        case 'SafeDict':
            return list(listordict.items())
        case 'SafeList':
            return listordict
        case _:
            err(f"{typeof(listordict)} cannot be converted to a list.\n{listordict} caused this error.",True)

def _round_nicely(number: int|float) -> str:
    """
    Makes the number look nice, regardless of whether it's an int or a float
    :arg number: an integer or float
    :return: the rounded number as a string
    """
    return f'{number:.2f}'.rstrip('0').rstrip('.')
